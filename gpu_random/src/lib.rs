#![no_std]

use core::f32::consts::PI;
#[allow(unused_imports)]
use num::Float;

pub mod philox;
pub mod widening_mul;

/// The [GPURng] trait represent random number generator which should  be compatible with [RustGPU](https://rust-gpu.github.io) when targeting for WebGPU with the WASM32 target architecture.
///
/// NOTE: Structs implementing this trait are supposed to only use 32 bits primitives. Other primitives such as u64 are prohibited as they are not compatible with WebGPU.
pub trait GPURng {
    /// Compute next random u32
    fn next_u32(&mut self) -> u32;
    /// Compute next uniform random f32 in [0,1)
    fn next_uniform(&mut self) -> f32 {
        let exp = 0x3f800000;
        let mask = 0x007fffff;
        f32::from_bits(exp | (self.next_u32() & mask)) - 1.0
    }
    /// Compute next uniform random f32 in range [min,max)
    fn next_uniform_range(&mut self, min: f32, max: f32) -> f32 {
        min + (max - min) * self.next_uniform()
    }
    /// Compute next pair of random numbers with centered reduced normal distribution.
    /// Normally distributed numbers are generated by pair with this method.
    fn next_normal_pair(&mut self) -> [f32; 2] {
        let u1 = self.next_uniform();
        let u2 = self.next_uniform();
        let sqrtln2u1 = (-2.0 * u1.ln()).sqrt();
        let pi2u2 = 2.0 * PI * u2;
        let n1 = sqrtln2u1 * pi2u2.cos();
        let n2 = sqrtln2u1 * pi2u2.sin();
        [n1, n2]
    }
    /// Compute next random number with normal distribution of mean `mu` and standard deviation `sigma`.
    ///
    /// NOTE: This method is provided for convenience but it is suboptimal as it discards one of the two normally distributed numbers computed by [GPURng::next_normal_pair]. It is preferable to reimplement this method by storing and reusing the second number from the pair later.
    fn next_normal(&mut self, mu: f32, sigma: f32) -> f32 {
        mu + sigma * self.next_normal_pair()[0]
    }
}
